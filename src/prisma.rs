// File generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR : & 'static str = include_str ! ("/home/sbchild/mc-auth/prisma/schema.prisma") ; static DATABASE_STR : & 'static str = "postgresql" ; use :: prisma_client_rust :: migrations :: include_dir ; pub static MIGRATIONS_DIR : & :: prisma_client_rust :: migrations :: include_dir :: Dir = & :: prisma_client_rust :: migrations :: include_dir :: include_dir ! ("/home/sbchild/mc-auth/prisma/migrations") ; pub use _prisma :: * ; use prisma_client_rust :: scalar_types :: * ; # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum UploadableTextures { # [serde (rename = "SkinOnly")] SkinOnly , # [serde (rename = "SkinAndCape")] SkinAndCape , # [serde (rename = "None")] None } impl ToString for UploadableTextures { fn to_string (& self) -> String { match self { Self :: SkinOnly => "SkinOnly" . to_string () , Self :: SkinAndCape => "SkinAndCape" . to_string () , Self :: None => "None" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SkinType { # [serde (rename = "Default")] Default , # [serde (rename = "Slim")] Slim } impl ToString for SkinType { fn to_string (& self) -> String { match self { Self :: Default => "Default" . to_string () , Self :: Slim => "Slim" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum Language { # [serde (rename = "ZH_CN")] ZhCn , # [serde (rename = "EN")] En } impl ToString for Language { fn to_string (& self) -> String { match self { Self :: ZhCn => "ZH_CN" . to_string () , Self :: En => "EN" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TokenStatus { # [serde (rename = "Available")] Available , # [serde (rename = "NeedRefresh")] NeedRefresh , # [serde (rename = "Invalid")] Invalid } impl ToString for TokenStatus { fn to_string (& self) -> String { match self { Self :: Available => "Available" . to_string () , Self :: NeedRefresh => "NeedRefresh" . to_string () , Self :: Invalid => "Invalid" . to_string () } } } pub mod _prisma { use super :: * ; pub struct PrismaClientBuilder { url : Option < String > , action_notifier : :: prisma_client_rust :: ActionNotifier , } impl PrismaClientBuilder { fn new () -> Self { Self { url : None , action_notifier : :: prisma_client_rust :: ActionNotifier :: new () } } pub fn with_url (mut self , url : String) -> Self { self . url = Some (url) ; self } pub async fn build (self) -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { let internals = :: prisma_client_rust :: PrismaClientInternals :: new (self . url , self . action_notifier , super :: DATAMODEL_STR) . await ? ; Ok (PrismaClient (internals)) } } pub struct PrismaClient (:: prisma_client_rust :: PrismaClientInternals) ; impl :: std :: fmt :: Debug for PrismaClient { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . debug_struct ("PrismaClient") . finish () } } impl PrismaClient { pub fn _builder () -> PrismaClientBuilder { PrismaClientBuilder :: new () } pub fn _query_raw < T : :: prisma_client_rust :: Data > (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: QueryRaw < T > { :: prisma_client_rust :: QueryRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub fn _execute_raw (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: ExecuteRaw { :: prisma_client_rust :: ExecuteRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub async fn _batch < 'batch , T : :: prisma_client_rust :: BatchContainer < 'batch , Marker > , Marker > (& self , queries : T) -> :: prisma_client_rust :: Result << T as :: prisma_client_rust :: BatchContainer < 'batch , Marker >> :: ReturnType > { :: prisma_client_rust :: batch (queries , & self . 0) . await } pub fn _transaction (& self) -> :: prisma_client_rust :: TransactionBuilder < Self > { :: prisma_client_rust :: TransactionBuilder :: _new (self , & self . 0) } pub async fn _migrate_deploy (& self) -> Result < () , :: prisma_client_rust :: migrations :: MigrateDeployError > { let res = :: prisma_client_rust :: migrations :: migrate_deploy (super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url ()) . await ; :: prisma_client_rust :: tokio :: time :: sleep (core :: time :: Duration :: from_millis (1)) . await ; res } pub async fn _migrate_resolve (& self , migration : & str) -> Result < () , :: prisma_client_rust :: migrations :: MigrateResolveError > { :: prisma_client_rust :: migrations :: migrate_resolve (migration , super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url () ,) . await } pub fn _db_push (& self) -> :: prisma_client_rust :: migrations :: DbPush { :: prisma_client_rust :: migrations :: db_push (super :: DATAMODEL_STR , & self . 0 . url ()) } pub fn skin (& self) -> super :: skin :: Actions { super :: skin :: Actions { client : & self . 0 , } } pub fn cape (& self) -> super :: cape :: Actions { super :: cape :: Actions { client : & self . 0 , } } pub fn profile (& self) -> super :: profile :: Actions { super :: profile :: Actions { client : & self . 0 , } } pub fn user (& self) -> super :: user :: Actions { super :: user :: Actions { client : & self . 0 , } } pub fn token (& self) -> super :: token :: Actions { super :: token :: Actions { client : & self . 0 , } } pub fn join_request (& self) -> super :: join_request :: Actions { super :: join_request :: Actions { client : & self . 0 , } } pub fn setting (& self) -> super :: setting :: Actions { super :: setting :: Actions { client : & self . 0 , } } } impl :: prisma_client_rust :: PrismaClient for PrismaClient { fn internals (& self) -> & :: prisma_client_rust :: PrismaClientInternals { & self . 0 } fn internals_mut (& mut self) -> & mut :: prisma_client_rust :: PrismaClientInternals { & mut self . 0 } fn with_tx_id (& self , tx_id : Option < :: prisma_client_rust :: query_core :: TxId >) -> Self { Self (self . 0 . with_tx_id (tx_id)) } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TransactionIsolationLevel { # [serde (rename = "ReadUncommitted")] ReadUncommitted , # [serde (rename = "ReadCommitted")] ReadCommitted , # [serde (rename = "RepeatableRead")] RepeatableRead , # [serde (rename = "Serializable")] Serializable } impl ToString for TransactionIsolationLevel { fn to_string (& self) -> String { match self { Self :: ReadUncommitted => "ReadUncommitted" . to_string () , Self :: ReadCommitted => "ReadCommitted" . to_string () , Self :: RepeatableRead => "RepeatableRead" . to_string () , Self :: Serializable => "Serializable" . to_string () } } } impl :: prisma_client_rust :: TransactionIsolationLevel for TransactionIsolationLevel { } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SkinScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "hash")] Hash , # [serde (rename = "model")] Model , # [serde (rename = "createdAt")] CreatedAt } impl ToString for SkinScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Hash => "hash" . to_string () , Self :: Model => "model" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum CapeScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "hash")] Hash , # [serde (rename = "createdAt")] CreatedAt } impl ToString for CapeScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Hash => "hash" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum ProfileScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "uuid")] Uuid , # [serde (rename = "ownerID")] OwnerId , # [serde (rename = "displayName")] DisplayName , # [serde (rename = "skinID")] SkinId , # [serde (rename = "capeID")] CapeId , # [serde (rename = "uploadableTextures")] UploadableTextures , # [serde (rename = "createdAt")] CreatedAt } impl ToString for ProfileScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Uuid => "uuid" . to_string () , Self :: OwnerId => "ownerID" . to_string () , Self :: DisplayName => "displayName" . to_string () , Self :: SkinId => "skinID" . to_string () , Self :: CapeId => "capeID" . to_string () , Self :: UploadableTextures => "uploadableTextures" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum UserScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "uuid")] Uuid , # [serde (rename = "nickname")] Nickname , # [serde (rename = "email")] Email , # [serde (rename = "password")] Password , # [serde (rename = "language")] Language , # [serde (rename = "createdAt")] CreatedAt } impl ToString for UserScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Uuid => "uuid" . to_string () , Self :: Nickname => "nickname" . to_string () , Self :: Email => "email" . to_string () , Self :: Password => "password" . to_string () , Self :: Language => "language" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TokenScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "accessToken")] AccessToken , # [serde (rename = "clientToken")] ClientToken , # [serde (rename = "ownerID")] OwnerId , # [serde (rename = "profileID")] ProfileId , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "status")] Status } impl ToString for TokenScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: AccessToken => "accessToken" . to_string () , Self :: ClientToken => "clientToken" . to_string () , Self :: OwnerId => "ownerID" . to_string () , Self :: ProfileId => "profileID" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: Status => "status" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum JoinRequestScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "serverID")] ServerId , # [serde (rename = "accessToken")] AccessToken , # [serde (rename = "ip")] Ip , # [serde (rename = "createdAt")] CreatedAt } impl ToString for JoinRequestScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: ServerId => "serverID" . to_string () , Self :: AccessToken => "accessToken" . to_string () , Self :: Ip => "ip" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SettingScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "userId")] UserId , # [serde (rename = "maxToken")] MaxToken , # [serde (rename = "tokenNeedRefreshDuration")] TokenNeedRefreshDuration , # [serde (rename = "tokenInvalidDuration")] TokenInvalidDuration } impl ToString for SettingScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: UserId => "userId" . to_string () , Self :: MaxToken => "maxToken" . to_string () , Self :: TokenNeedRefreshDuration => "tokenNeedRefreshDuration" . to_string () , Self :: TokenInvalidDuration => "tokenInvalidDuration" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SortOrder { # [serde (rename = "asc")] Asc , # [serde (rename = "desc")] Desc } impl ToString for SortOrder { fn to_string (& self) -> String { match self { Self :: Asc => "asc" . to_string () , Self :: Desc => "desc" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum QueryMode { # [serde (rename = "default")] Default , # [serde (rename = "insensitive")] Insensitive } impl ToString for QueryMode { fn to_string (& self) -> String { match self { Self :: Default => "default" . to_string () , Self :: Insensitive => "insensitive" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum NullsOrder { # [serde (rename = "first")] First , # [serde (rename = "last")] Last } impl ToString for NullsOrder { fn to_string (& self) -> String { match self { Self :: First => "first" . to_string () , Self :: Last => "last" . to_string () } } } impl Into < :: prisma_client_rust :: PrismaValue > for SortOrder { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { SortOrder :: Asc => :: prisma_client_rust :: PrismaValue :: String ("asc" . to_string ()) , SortOrder :: Desc => :: prisma_client_rust :: PrismaValue :: String ("desc" . to_string ()) , } } } pub mod read_filters { use super :: * ; # [derive (Debug , Clone)] pub enum StringFilter { Equals (String) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Mode (super :: super :: QueryMode) , Not (String) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Mode (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("mode" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) } } } # [derive (Debug , Clone)] pub enum BigIntFilter { Equals (BigInt) , InVec (Vec < BigInt >) , NotInVec (Vec < BigInt >) , Lt (BigInt) , Lte (BigInt) , Gt (BigInt) , Gte (BigInt) , Not (BigInt) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for BigIntFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) } } } # [derive (Debug , Clone)] pub enum BigIntNullableFilter { Equals (Option < BigInt >) , InVec (Vec < BigInt >) , NotInVec (Vec < BigInt >) , Lt (BigInt) , Lte (BigInt) , Gt (BigInt) , Gte (BigInt) , Not (Option < BigInt >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for BigIntNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } # [derive (Debug , Clone)] pub enum DateTimeFilter { Equals (DateTime) , InVec (Vec < DateTime >) , NotInVec (Vec < DateTime >) , Lt (DateTime) , Lte (DateTime) , Gt (DateTime) , Gte (DateTime) , Not (DateTime) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for DateTimeFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) } } } # [derive (Debug , Clone)] pub enum BytesFilter { Equals (Bytes) , InVec (Vec < Bytes >) , NotInVec (Vec < Bytes >) , Not (Bytes) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for BytesFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Bytes (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Bytes (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Bytes (value)) . collect ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Bytes (value))]) } } } # [derive (Debug , Clone)] pub enum UploadableTexturesFilter { Equals (super :: super :: UploadableTextures) , InVec (Vec < super :: super :: UploadableTextures >) , NotInVec (Vec < super :: super :: UploadableTextures >) , Not (super :: super :: UploadableTextures) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for UploadableTexturesFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) } } } # [derive (Debug , Clone)] pub enum SkinTypeFilter { Equals (super :: super :: SkinType) , InVec (Vec < super :: super :: SkinType >) , NotInVec (Vec < super :: super :: SkinType >) , Not (super :: super :: SkinType) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for SkinTypeFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) } } } # [derive (Debug , Clone)] pub enum LanguageFilter { Equals (super :: super :: Language) , InVec (Vec < super :: super :: Language >) , NotInVec (Vec < super :: super :: Language >) , Not (super :: super :: Language) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for LanguageFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) } } } # [derive (Debug , Clone)] pub enum TokenStatusFilter { Equals (super :: super :: TokenStatus) , InVec (Vec < super :: super :: TokenStatus >) , NotInVec (Vec < super :: super :: TokenStatus >) , Not (super :: super :: TokenStatus) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for TokenStatusFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ())) . collect ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()))]) } } } } pub mod write_params { use super :: * ; # [derive (Debug , Clone)] pub enum BigIntParam { Set (BigInt) , Increment (BigInt) , Decrement (BigInt) , Multiply (BigInt) , Divide (BigInt) } impl Into < :: prisma_client_rust :: PrismaValue > for BigIntParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: BigInt (value) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) } } } # [derive (Debug , Clone)] pub enum BigIntNullableParam { Set (Option < BigInt >) , Increment (BigInt) , Decrement (BigInt) , Multiply (BigInt) , Divide (BigInt) } impl Into < :: prisma_client_rust :: PrismaValue > for BigIntNullableParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: BigInt (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) } } } # [derive (Debug , Clone)] pub enum BytesParam { Set (Bytes) } impl Into < :: prisma_client_rust :: PrismaValue > for BytesParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Bytes (value) } } } # [derive (Debug , Clone)] pub enum DateTimeParam { Set (DateTime) } impl Into < :: prisma_client_rust :: PrismaValue > for DateTimeParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: DateTime (value) } } } # [derive (Debug , Clone)] pub enum LanguageParam { Set (super :: super :: Language) } impl Into < :: prisma_client_rust :: PrismaValue > for LanguageParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()) } } } # [derive (Debug , Clone)] pub enum SkinTypeParam { Set (super :: super :: SkinType) } impl Into < :: prisma_client_rust :: PrismaValue > for SkinTypeParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()) } } } # [derive (Debug , Clone)] pub enum StringParam { Set (String) } impl Into < :: prisma_client_rust :: PrismaValue > for StringParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: String (value) } } } # [derive (Debug , Clone)] pub enum TokenStatusParam { Set (super :: super :: TokenStatus) } impl Into < :: prisma_client_rust :: PrismaValue > for TokenStatusParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()) } } } # [derive (Debug , Clone)] pub enum UploadableTexturesParam { Set (super :: super :: UploadableTextures) } impl Into < :: prisma_client_rust :: PrismaValue > for UploadableTexturesParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Enum (value . to_string ()) } } } } } pub mod skin { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Skin" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , Hash (super :: _prisma :: read_filters :: BytesFilter) , Model (super :: _prisma :: read_filters :: SkinTypeFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , ProfileSome (Vec < super :: profile :: WhereParam >) , ProfileEvery (Vec < super :: profile :: WhereParam >) , ProfileNone (Vec < super :: profile :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Hash (value) => (hash :: NAME , value . into ()) , Self :: Model (value) => (model :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ProfileSome (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileEvery (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileNone (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Hash (super :: SortOrder) , Model (super :: SortOrder) , CreatedAt (super :: SortOrder) , Profile (Vec < super :: profile :: OrderByRelationAggregateParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Hash (param) => ("hash" , param . into ()) , Self :: Model (param) => ("model" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Profile (param) => ("Profile" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Profile (super :: profile :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Profile (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (profile :: NAME , None , arguments , nested_selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Hash (super :: _prisma :: write_params :: BytesParam) , Model (super :: _prisma :: write_params :: SkinTypeParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , ConnectProfile (Vec < super :: profile :: UniqueWhereParam >) , DisconnectProfile (Vec < super :: profile :: UniqueWhereParam >) , SetProfile (Vec < super :: profile :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Hash (value) => (hash :: NAME , value . into ()) , Self :: Model (value) => (model :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ConnectProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Hash (super :: _prisma :: write_params :: BytesParam) , Model (super :: _prisma :: write_params :: SkinTypeParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Hash (value) => ("hash" , value . into ()) , Self :: Model (value) => ("model" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_skin , select , prisma :: skin , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "hash")] hash : hash :: Type , # [serde (rename = "model")] model : model :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "Profile")] profile : profile :: Type } , [(id , Scalar) , (hash , Scalar) , (model , Scalar) , (created_at , Scalar) , (profile , Relation (prisma :: profile , Many))]) ; pub enum SelectParam { Id (id :: Select) , Hash (hash :: Select) , Model (model :: Select) , CreatedAt (created_at :: Select) , Profile (profile :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Hash (data) => data . into () , Self :: Model (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Profile (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_skin , include , prisma :: skin , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "hash")] hash : hash :: Type , # [serde (rename = "model")] model : model :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "Profile")] profile : profile :: Type } , [(profile , Relation (prisma :: profile , Many))]) ; pub enum IncludeParam { Id (id :: Include) , Hash (hash :: Include) , Model (model :: Include) , CreatedAt (created_at :: Include) , Profile (profile :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Hash (data) => data . into () , Self :: Model (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Profile (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub hash : Bytes , pub model : super :: SkinType , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . skin () . create (self . hash , self . model , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([hash :: set (self . hash) , model :: set (self . model)]) ; self . _params } } pub fn create (hash : Bytes , model : super :: SkinType , _params : Vec < SetParam >) -> Create { Create { hash , model , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub hash : Bytes , pub model : super :: SkinType , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . skin () . create_unchecked (self . hash , self . model , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([hash :: set (self . hash) , model :: set (self . model)]) ; self . _params } } pub fn create_unchecked (hash : Bytes , model : super :: SkinType , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { hash , model , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (hash :: NAME) , :: prisma_client_rust :: sel (model :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "hash")] pub hash : hash :: Type , # [serde (rename = "model")] pub model : model :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "Profile")] pub profile : Option < profile :: RecursiveSafeType > } impl Data { pub fn profile (& self) -> Result < & profile :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . profile . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (profile))) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_skin , prisma :: skin , struct Data { # [serde (rename = "id")] pub id : prisma :: skin :: id :: Type , # [serde (rename = "hash")] pub hash : prisma :: skin :: hash :: Type , # [serde (rename = "model")] pub model : prisma :: skin :: model :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: skin :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_skin_filter , prisma :: skin , [(id , Scalar) , (hash , Scalar) , (model , Scalar) , (created_at , Scalar) , (profile , Relation (prisma :: profile , Many))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , hash : Bytes , model : super :: SkinType , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([hash :: set (hash) , model :: set (model)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , hash : Bytes , model : super :: SkinType , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([hash :: set (hash) , model :: set (model)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod profile { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "Profile" ; pub type Type = Vec < profile :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileSome (value) } pub fn every (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileEvery (value) } pub fn none (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileNone (value) } pub struct Order (Vec < profile :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < profile :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Profile (v) } } pub struct Fetch (pub profile :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < profile :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : profile :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : profile :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Profile (v) } } pub fn fetch (params : Vec < profile :: WhereParam >) -> Fetch { Fetch (profile :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < profile :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectProfile (v) } } pub fn connect < T : From < Connect >> (params : Vec < profile :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < profile :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectProfile (params) } pub fn set (params : Vec < profile :: UniqueWhereParam >) -> SetParam { SetParam :: SetProfile (params) } pub enum Select { Select (profile :: ManyArgs , Vec < profile :: SelectParam >) , Include (profile :: ManyArgs , Vec < profile :: IncludeParam >) , Fetch (profile :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Profile (self) } } impl Select { pub fn select (args : profile :: ManyArgs , nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : profile :: ManyArgs , nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (profile :: ManyArgs , Vec < profile :: SelectParam >) , Include (profile :: ManyArgs , Vec < profile :: IncludeParam >) , Fetch (profile :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Profile (self) } } impl Include { pub fn select (args : profile :: ManyArgs , nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : profile :: ManyArgs , nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : DateTime) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : DateTime) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod hash { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "hash" ; pub type Type = Bytes ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Bytes) ; pub fn equals < T : From < Equals >> (value : Bytes) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Hash (_prisma :: read_filters :: BytesFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BytesFilter , Hash , { fn in_vec (_ : Vec < Bytes >) -> InVec ; fn not_in_vec (_ : Vec < Bytes >) -> NotInVec ; fn not (_ : Bytes) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Hash (v) } } pub struct Set (pub Bytes) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Hash (_prisma :: write_params :: BytesParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Bytes) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BytesParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Hash (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Hash (_prisma :: write_params :: BytesParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Hash (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Hash (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Hash (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod model { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "model" ; pub type Type = super :: super :: SkinType ; pub type RecursiveSafeType = Type ; pub struct Equals (pub SkinType) ; pub fn equals < T : From < Equals >> (value : SkinType) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Model (_prisma :: read_filters :: SkinTypeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: SkinTypeFilter , Model , { fn in_vec (_ : Vec < SkinType >) -> InVec ; fn not_in_vec (_ : Vec < SkinType >) -> NotInVec ; fn not (_ : SkinType) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Model (v) } } pub struct Set (pub SkinType) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Model (_prisma :: write_params :: SkinTypeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : SkinType) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: SkinTypeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Model (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Model (_prisma :: write_params :: SkinTypeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Model (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Model (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Model (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod cape { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Cape" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , Hash (super :: _prisma :: read_filters :: BytesFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , ProfileSome (Vec < super :: profile :: WhereParam >) , ProfileEvery (Vec < super :: profile :: WhereParam >) , ProfileNone (Vec < super :: profile :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Hash (value) => (hash :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ProfileSome (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileEvery (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileNone (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Hash (super :: SortOrder) , CreatedAt (super :: SortOrder) , Profile (Vec < super :: profile :: OrderByRelationAggregateParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Hash (param) => ("hash" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Profile (param) => ("Profile" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Profile (super :: profile :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Profile (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (profile :: NAME , None , arguments , nested_selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Hash (super :: _prisma :: write_params :: BytesParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , ConnectProfile (Vec < super :: profile :: UniqueWhereParam >) , DisconnectProfile (Vec < super :: profile :: UniqueWhereParam >) , SetProfile (Vec < super :: profile :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Hash (value) => (hash :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ConnectProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Hash (super :: _prisma :: write_params :: BytesParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Hash (value) => ("hash" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_cape , select , prisma :: cape , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "hash")] hash : hash :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "Profile")] profile : profile :: Type } , [(id , Scalar) , (hash , Scalar) , (created_at , Scalar) , (profile , Relation (prisma :: profile , Many))]) ; pub enum SelectParam { Id (id :: Select) , Hash (hash :: Select) , CreatedAt (created_at :: Select) , Profile (profile :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Hash (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Profile (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_cape , include , prisma :: cape , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "hash")] hash : hash :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "Profile")] profile : profile :: Type } , [(profile , Relation (prisma :: profile , Many))]) ; pub enum IncludeParam { Id (id :: Include) , Hash (hash :: Include) , CreatedAt (created_at :: Include) , Profile (profile :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Hash (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Profile (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub hash : Bytes , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . cape () . create (self . hash , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([hash :: set (self . hash)]) ; self . _params } } pub fn create (hash : Bytes , _params : Vec < SetParam >) -> Create { Create { hash , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub hash : Bytes , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . cape () . create_unchecked (self . hash , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([hash :: set (self . hash)]) ; self . _params } } pub fn create_unchecked (hash : Bytes , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { hash , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (hash :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "hash")] pub hash : hash :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "Profile")] pub profile : Option < profile :: RecursiveSafeType > } impl Data { pub fn profile (& self) -> Result < & profile :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . profile . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (profile))) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_cape , prisma :: cape , struct Data { # [serde (rename = "id")] pub id : prisma :: cape :: id :: Type , # [serde (rename = "hash")] pub hash : prisma :: cape :: hash :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: cape :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_cape_filter , prisma :: cape , [(id , Scalar) , (hash , Scalar) , (created_at , Scalar) , (profile , Relation (prisma :: profile , Many))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , hash : Bytes , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([hash :: set (hash)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , hash : Bytes , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([hash :: set (hash)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod profile { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "Profile" ; pub type Type = Vec < profile :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileSome (value) } pub fn every (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileEvery (value) } pub fn none (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileNone (value) } pub struct Order (Vec < profile :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < profile :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Profile (v) } } pub struct Fetch (pub profile :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < profile :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : profile :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : profile :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Profile (v) } } pub fn fetch (params : Vec < profile :: WhereParam >) -> Fetch { Fetch (profile :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < profile :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectProfile (v) } } pub fn connect < T : From < Connect >> (params : Vec < profile :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < profile :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectProfile (params) } pub fn set (params : Vec < profile :: UniqueWhereParam >) -> SetParam { SetParam :: SetProfile (params) } pub enum Select { Select (profile :: ManyArgs , Vec < profile :: SelectParam >) , Include (profile :: ManyArgs , Vec < profile :: IncludeParam >) , Fetch (profile :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Profile (self) } } impl Select { pub fn select (args : profile :: ManyArgs , nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : profile :: ManyArgs , nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (profile :: ManyArgs , Vec < profile :: SelectParam >) , Include (profile :: ManyArgs , Vec < profile :: IncludeParam >) , Fetch (profile :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Profile (self) } } impl Include { pub fn select (args : profile :: ManyArgs , nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : profile :: ManyArgs , nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : DateTime) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : DateTime) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod hash { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "hash" ; pub type Type = Bytes ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Bytes) ; pub fn equals < T : From < Equals >> (value : Bytes) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Hash (_prisma :: read_filters :: BytesFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BytesFilter , Hash , { fn in_vec (_ : Vec < Bytes >) -> InVec ; fn not_in_vec (_ : Vec < Bytes >) -> NotInVec ; fn not (_ : Bytes) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Hash (v) } } pub struct Set (pub Bytes) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Hash (_prisma :: write_params :: BytesParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Bytes) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BytesParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Hash (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Hash (_prisma :: write_params :: BytesParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Hash (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Hash (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Hash (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod profile { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Profile" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , Uuid (super :: _prisma :: read_filters :: BytesFilter) , OwnerId (super :: _prisma :: read_filters :: BigIntFilter) , DisplayName (super :: _prisma :: read_filters :: StringFilter) , SkinId (super :: _prisma :: read_filters :: BigIntNullableFilter) , CapeId (super :: _prisma :: read_filters :: BigIntNullableFilter) , UploadableTextures (super :: _prisma :: read_filters :: UploadableTexturesFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , CapeIsNull , CapeIs (Vec < super :: cape :: WhereParam >) , CapeIsNot (Vec < super :: cape :: WhereParam >) , OwnerIs (Vec < super :: user :: WhereParam >) , OwnerIsNot (Vec < super :: user :: WhereParam >) , SkinIsNull , SkinIs (Vec < super :: skin :: WhereParam >) , SkinIsNot (Vec < super :: skin :: WhereParam >) , TokenSome (Vec < super :: token :: WhereParam >) , TokenEvery (Vec < super :: token :: WhereParam >) , TokenNone (Vec < super :: token :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Uuid (value) => (uuid :: NAME , value . into ()) , Self :: OwnerId (value) => (owner_id :: NAME , value . into ()) , Self :: DisplayName (value) => (display_name :: NAME , value . into ()) , Self :: SkinId (value) => (skin_id :: NAME , value . into ()) , Self :: CapeId (value) => (cape_id :: NAME , value . into ()) , Self :: UploadableTextures (value) => (uploadable_textures :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: CapeIsNull => (cape :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Null)) , Self :: CapeIs (where_params) => (cape :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: CapeIsNot (where_params) => (cape :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: OwnerIs (where_params) => (owner :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: OwnerIsNot (where_params) => (owner :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: SkinIsNull => (skin :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Null)) , Self :: SkinIs (where_params) => (skin :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: SkinIsNot (where_params) => (skin :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenSome (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenEvery (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenNone (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) , UuidEquals (Bytes) , DisplayNameEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) , UniqueWhereParam :: UuidEquals (value) => ("uuid" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Bytes (value))) , UniqueWhereParam :: DisplayNameEquals (value) => ("displayName" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Uuid (super :: SortOrder) , OwnerId (super :: SortOrder) , DisplayName (super :: SortOrder) , SkinId (super :: SortOrder) , CapeId (super :: SortOrder) , UploadableTextures (super :: SortOrder) , CreatedAt (super :: SortOrder) , Cape (Vec < super :: cape :: OrderByWithRelationParam >) , Owner (Vec < super :: user :: OrderByWithRelationParam >) , Skin (Vec < super :: skin :: OrderByWithRelationParam >) , Token (Vec < super :: token :: OrderByRelationAggregateParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Uuid (param) => ("uuid" , param . into ()) , Self :: OwnerId (param) => ("ownerID" , param . into ()) , Self :: DisplayName (param) => ("displayName" , param . into ()) , Self :: SkinId (param) => ("skinID" , param . into ()) , Self :: CapeId (param) => ("capeID" , param . into ()) , Self :: UploadableTextures (param) => ("uploadableTextures" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Cape (param) => ("cape" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Owner (param) => ("owner" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Skin (param) => ("skin" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Token (param) => ("Token" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum OrderByRelationAggregateParam { _Count (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByRelationAggregateParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: _Count (param) => ("_count" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Cape (super :: cape :: UniqueArgs) , Owner (super :: user :: UniqueArgs) , Skin (super :: skin :: UniqueArgs) , Token (super :: token :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Cape (args) => { let mut selections = < super :: cape :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (cape :: NAME , None , [] , selections) } , Self :: Owner (args) => { let mut selections = < super :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (owner :: NAME , None , [] , selections) } , Self :: Skin (args) => { let mut selections = < super :: skin :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (skin :: NAME , None , [] , selections) } , Self :: Token (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (token :: NAME , None , arguments , nested_selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Uuid (super :: _prisma :: write_params :: BytesParam) , OwnerId (super :: _prisma :: write_params :: BigIntParam) , DisplayName (super :: _prisma :: write_params :: StringParam) , SkinId (super :: _prisma :: write_params :: BigIntNullableParam) , CapeId (super :: _prisma :: write_params :: BigIntNullableParam) , UploadableTextures (super :: _prisma :: write_params :: UploadableTexturesParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , ConnectCape (super :: cape :: UniqueWhereParam) , DisconnectCape , ConnectOwner (super :: user :: UniqueWhereParam) , ConnectSkin (super :: skin :: UniqueWhereParam) , DisconnectSkin , ConnectToken (Vec < super :: token :: UniqueWhereParam >) , DisconnectToken (Vec < super :: token :: UniqueWhereParam >) , SetToken (Vec < super :: token :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Uuid (value) => (uuid :: NAME , value . into ()) , Self :: OwnerId (value) => (owner_id :: NAME , value . into ()) , Self :: DisplayName (value) => (display_name :: NAME , value . into ()) , Self :: SkinId (value) => (skin_id :: NAME , value . into ()) , Self :: CapeId (value) => (cape_id :: NAME , value . into ()) , Self :: UploadableTextures (value) => (uploadable_textures :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ConnectCape (where_param) => (cape :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: DisconnectCape => (cape :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) , Self :: ConnectOwner (where_param) => (owner :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: ConnectSkin (where_param) => (skin :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: DisconnectSkin => (skin :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) , Self :: ConnectToken (where_params) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectToken (where_params) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetToken (where_params) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Uuid (super :: _prisma :: write_params :: BytesParam) , OwnerId (super :: _prisma :: write_params :: BigIntParam) , DisplayName (super :: _prisma :: write_params :: StringParam) , SkinId (super :: _prisma :: write_params :: BigIntNullableParam) , CapeId (super :: _prisma :: write_params :: BigIntNullableParam) , UploadableTextures (super :: _prisma :: write_params :: UploadableTexturesParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Uuid (value) => ("uuid" , value . into ()) , Self :: OwnerId (value) => ("ownerID" , value . into ()) , Self :: DisplayName (value) => ("displayName" , value . into ()) , Self :: SkinId (value) => ("skinID" , value . into ()) , Self :: CapeId (value) => ("capeID" , value . into ()) , Self :: UploadableTextures (value) => ("uploadableTextures" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_profile , select , prisma :: profile , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "uuid")] uuid : uuid :: Type , # [serde (rename = "ownerID")] owner_id : owner_id :: Type , # [serde (rename = "displayName")] display_name : display_name :: Type , # [serde (rename = "skinID")] skin_id : skin_id :: Type , # [serde (rename = "capeID")] cape_id : cape_id :: Type , # [serde (rename = "uploadableTextures")] uploadable_textures : uploadable_textures :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "cape")] cape : cape :: Type , # [serde (rename = "owner")] owner : owner :: Type , # [serde (rename = "skin")] skin : skin :: Type , # [serde (rename = "Token")] token : token :: Type } , [(id , Scalar) , (uuid , Scalar) , (owner_id , Scalar) , (display_name , Scalar) , (skin_id , Scalar) , (cape_id , Scalar) , (uploadable_textures , Scalar) , (created_at , Scalar) , (cape , Relation (prisma :: cape , Optional)) , (owner , Relation (prisma :: user , One)) , (skin , Relation (prisma :: skin , Optional)) , (token , Relation (prisma :: token , Many))]) ; pub enum SelectParam { Id (id :: Select) , Uuid (uuid :: Select) , OwnerId (owner_id :: Select) , DisplayName (display_name :: Select) , SkinId (skin_id :: Select) , CapeId (cape_id :: Select) , UploadableTextures (uploadable_textures :: Select) , CreatedAt (created_at :: Select) , Cape (cape :: Select) , Owner (owner :: Select) , Skin (skin :: Select) , Token (token :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Uuid (data) => data . into () , Self :: OwnerId (data) => data . into () , Self :: DisplayName (data) => data . into () , Self :: SkinId (data) => data . into () , Self :: CapeId (data) => data . into () , Self :: UploadableTextures (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Cape (data) => data . into () , Self :: Owner (data) => data . into () , Self :: Skin (data) => data . into () , Self :: Token (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_profile , include , prisma :: profile , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "uuid")] uuid : uuid :: Type , # [serde (rename = "ownerID")] owner_id : owner_id :: Type , # [serde (rename = "displayName")] display_name : display_name :: Type , # [serde (rename = "skinID")] skin_id : skin_id :: Type , # [serde (rename = "capeID")] cape_id : cape_id :: Type , # [serde (rename = "uploadableTextures")] uploadable_textures : uploadable_textures :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "cape")] cape : cape :: Type , # [serde (rename = "owner")] owner : owner :: Type , # [serde (rename = "skin")] skin : skin :: Type , # [serde (rename = "Token")] token : token :: Type } , [(cape , Relation (prisma :: cape , Optional)) , (owner , Relation (prisma :: user , One)) , (skin , Relation (prisma :: skin , Optional)) , (token , Relation (prisma :: token , Many))]) ; pub enum IncludeParam { Id (id :: Include) , Uuid (uuid :: Include) , OwnerId (owner_id :: Include) , DisplayName (display_name :: Include) , SkinId (skin_id :: Include) , CapeId (cape_id :: Include) , UploadableTextures (uploadable_textures :: Include) , CreatedAt (created_at :: Include) , Cape (cape :: Include) , Owner (owner :: Include) , Skin (skin :: Include) , Token (token :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Uuid (data) => data . into () , Self :: OwnerId (data) => data . into () , Self :: DisplayName (data) => data . into () , Self :: SkinId (data) => data . into () , Self :: CapeId (data) => data . into () , Self :: UploadableTextures (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Cape (data) => data . into () , Self :: Owner (data) => data . into () , Self :: Skin (data) => data . into () , Self :: Token (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub uuid : Bytes , pub display_name : String , pub owner : super :: user :: UniqueWhereParam , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . profile () . create (self . uuid , self . display_name , self . owner , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([uuid :: set (self . uuid) , display_name :: set (self . display_name) , owner :: connect (self . owner)]) ; self . _params } } pub fn create (uuid : Bytes , display_name : String , owner : super :: user :: UniqueWhereParam , _params : Vec < SetParam >) -> Create { Create { uuid , display_name , owner , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub uuid : Bytes , pub owner_id : BigInt , pub display_name : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . profile () . create_unchecked (self . uuid , self . owner_id , self . display_name , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([uuid :: set (self . uuid) , owner_id :: set (self . owner_id) , display_name :: set (self . display_name)]) ; self . _params } } pub fn create_unchecked (uuid : Bytes , owner_id : BigInt , display_name : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { uuid , owner_id , display_name , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (uuid :: NAME) , :: prisma_client_rust :: sel (owner_id :: NAME) , :: prisma_client_rust :: sel (display_name :: NAME) , :: prisma_client_rust :: sel (skin_id :: NAME) , :: prisma_client_rust :: sel (cape_id :: NAME) , :: prisma_client_rust :: sel (uploadable_textures :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "uuid")] pub uuid : uuid :: Type , # [serde (rename = "ownerID")] pub owner_id : owner_id :: Type , # [serde (rename = "displayName")] pub display_name : display_name :: Type , # [serde (rename = "skinID")] pub skin_id : skin_id :: Type , # [serde (rename = "capeID")] pub cape_id : cape_id :: Type , # [serde (rename = "uploadableTextures")] pub uploadable_textures : uploadable_textures :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "cape" , default , skip_serializing_if = "Option::is_none" , with = "prisma_client_rust::serde::double_option")] pub cape : Option < cape :: RecursiveSafeType > , # [serde (rename = "owner")] pub owner : Option < owner :: RecursiveSafeType > , # [serde (rename = "skin" , default , skip_serializing_if = "Option::is_none" , with = "prisma_client_rust::serde::double_option")] pub skin : Option < skin :: RecursiveSafeType > , # [serde (rename = "Token")] pub token : Option < token :: RecursiveSafeType > } impl Data { pub fn cape (& self) -> Result < Option < & super :: cape :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . cape . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (cape))) . map (| v | v . as_ref () . map (| v | v . as_ref ())) } pub fn owner (& self) -> Result < & super :: user :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . owner . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (owner))) . map (| v | v . as_ref ()) } pub fn skin (& self) -> Result < Option < & super :: skin :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . skin . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (skin))) . map (| v | v . as_ref () . map (| v | v . as_ref ())) } pub fn token (& self) -> Result < & token :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . token . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (token))) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_profile , prisma :: profile , struct Data { # [serde (rename = "id")] pub id : prisma :: profile :: id :: Type , # [serde (rename = "uuid")] pub uuid : prisma :: profile :: uuid :: Type , # [serde (rename = "ownerID")] pub owner_id : prisma :: profile :: owner_id :: Type , # [serde (rename = "displayName")] pub display_name : prisma :: profile :: display_name :: Type , # [serde (rename = "skinID")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub skin_id : prisma :: profile :: skin_id :: Type , # [serde (rename = "capeID")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub cape_id : prisma :: profile :: cape_id :: Type , # [serde (rename = "uploadableTextures")] pub uploadable_textures : prisma :: profile :: uploadable_textures :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: profile :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_profile_filter , prisma :: profile , [(id , Scalar) , (uuid , Scalar) , (owner_id , Scalar) , (display_name , Scalar) , (skin_id , Scalar) , (cape_id , Scalar) , (uploadable_textures , Scalar) , (created_at , Scalar) , (cape , Relation (prisma :: cape , Optional)) , (owner , Relation (prisma :: user , One)) , (skin , Relation (prisma :: skin , Optional)) , (token , Relation (prisma :: token , Many))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , uuid : Bytes , display_name : String , owner : super :: user :: UniqueWhereParam , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([uuid :: set (uuid) , display_name :: set (display_name) , owner :: connect (owner)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , uuid : Bytes , owner_id : BigInt , display_name : String , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([uuid :: set (uuid) , owner_id :: set (owner_id) , display_name :: set (display_name)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "Token" ; pub type Type = Vec < token :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenSome (value) } pub fn every (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenEvery (value) } pub fn none (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenNone (value) } pub struct Order (Vec < token :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < token :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Token (v) } } pub struct Fetch (pub token :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < token :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : token :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : token :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Token (v) } } pub fn fetch (params : Vec < token :: WhereParam >) -> Fetch { Fetch (token :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < token :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectToken (v) } } pub fn connect < T : From < Connect >> (params : Vec < token :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < token :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectToken (params) } pub fn set (params : Vec < token :: UniqueWhereParam >) -> SetParam { SetParam :: SetToken (params) } pub enum Select { Select (token :: ManyArgs , Vec < token :: SelectParam >) , Include (token :: ManyArgs , Vec < token :: IncludeParam >) , Fetch (token :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Token (self) } } impl Select { pub fn select (args : token :: ManyArgs , nested_selections : Vec < token :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : token :: ManyArgs , nested_selections : Vec < token :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (token :: ManyArgs , Vec < token :: SelectParam >) , Include (token :: ManyArgs , Vec < token :: IncludeParam >) , Fetch (token :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Token (self) } } impl Include { pub fn select (args : token :: ManyArgs , nested_selections : Vec < token :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : token :: ManyArgs , nested_selections : Vec < token :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod _count { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "_count" ; pub struct Order (super :: SortOrder) ; pub fn order < T : From < Order >> (v : super :: SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByRelationAggregateParam { fn from (Order (v) : Order) -> Self { Self :: _Count (v) } } } pub mod cape { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "cape" ; pub type Type = Option < cape :: Data > ; pub type RecursiveSafeType = Option < Box < cape :: Data >> ; pub fn is (value : Vec < cape :: WhereParam >) -> WhereParam { WhereParam :: CapeIs (value) } pub fn is_not (value : Vec < cape :: WhereParam >) -> WhereParam { WhereParam :: CapeIsNot (value) } pub struct Order (Vec < cape :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < cape :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Cape (v) } } pub struct Fetch (pub cape :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < cape :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Cape (v) } } pub fn fetch () -> Fetch { Fetch (cape :: UniqueArgs :: new ()) } pub struct Connect (cape :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectCape (v) } } pub fn connect < T : From < Connect >> (value : cape :: UniqueWhereParam) -> T { Connect (value) . into () } pub fn disconnect () -> SetParam { SetParam :: DisconnectCape } pub fn is_null () -> WhereParam { WhereParam :: CapeIsNull } pub enum Select { Select (Vec < cape :: SelectParam >) , Include (Vec < cape :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Cape (self) } } impl Select { pub fn select (nested_selections : Vec < cape :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < cape :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < cape :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("cape" , None , [] , selections) } } pub enum Include { Select (Vec < cape :: SelectParam >) , Include (Vec < cape :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Cape (self) } } impl Include { pub fn select (nested_selections : Vec < cape :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < cape :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < cape :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < cape :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("cape" , None , [] , selections) } } } pub mod cape_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "capeID" ; pub type Type = Option < BigInt > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < BigInt >) ; pub fn equals < T : From < Equals >> (value : Option < BigInt >) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CapeId (_prisma :: read_filters :: BigIntNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntNullableFilter , CapeId , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : Option < BigInt >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CapeId (v) } } pub struct Set (pub Option < BigInt >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CapeId (_prisma :: write_params :: BigIntNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Option < BigInt >) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CapeId (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CapeId (_prisma :: write_params :: BigIntNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CapeId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CapeId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CapeId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : DateTime) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : DateTime) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod display_name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "displayName" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: DisplayNameEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: DisplayName (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , DisplayName , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: DisplayName (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: DisplayName (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: DisplayName (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: DisplayName (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: DisplayName (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: DisplayName (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: DisplayName (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod owner { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "owner" ; pub type Type = user :: Data ; pub type RecursiveSafeType = Box < user :: Data > ; pub fn is (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: OwnerIs (value) } pub fn is_not (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: OwnerIsNot (value) } pub struct Order (Vec < user :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < user :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Owner (v) } } pub struct Fetch (pub user :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < user :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Owner (v) } } pub fn fetch () -> Fetch { Fetch (user :: UniqueArgs :: new ()) } pub struct Connect (user :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectOwner (v) } } pub fn connect < T : From < Connect >> (value : user :: UniqueWhereParam) -> T { Connect (value) . into () } pub enum Select { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Owner (self) } } impl Select { pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("owner" , None , [] , selections) } } pub enum Include { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Owner (self) } } impl Include { pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("owner" , None , [] , selections) } } } pub mod owner_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "ownerID" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: OwnerId (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , OwnerId , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: OwnerId (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: OwnerId (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: OwnerId (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: OwnerId (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: OwnerId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: OwnerId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: OwnerId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod skin { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "skin" ; pub type Type = Option < skin :: Data > ; pub type RecursiveSafeType = Option < Box < skin :: Data >> ; pub fn is (value : Vec < skin :: WhereParam >) -> WhereParam { WhereParam :: SkinIs (value) } pub fn is_not (value : Vec < skin :: WhereParam >) -> WhereParam { WhereParam :: SkinIsNot (value) } pub struct Order (Vec < skin :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < skin :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Skin (v) } } pub struct Fetch (pub skin :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < skin :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Skin (v) } } pub fn fetch () -> Fetch { Fetch (skin :: UniqueArgs :: new ()) } pub struct Connect (skin :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectSkin (v) } } pub fn connect < T : From < Connect >> (value : skin :: UniqueWhereParam) -> T { Connect (value) . into () } pub fn disconnect () -> SetParam { SetParam :: DisconnectSkin } pub fn is_null () -> WhereParam { WhereParam :: SkinIsNull } pub enum Select { Select (Vec < skin :: SelectParam >) , Include (Vec < skin :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Skin (self) } } impl Select { pub fn select (nested_selections : Vec < skin :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < skin :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < skin :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("skin" , None , [] , selections) } } pub enum Include { Select (Vec < skin :: SelectParam >) , Include (Vec < skin :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Skin (self) } } impl Include { pub fn select (nested_selections : Vec < skin :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < skin :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < skin :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < skin :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("skin" , None , [] , selections) } } } pub mod skin_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "skinID" ; pub type Type = Option < BigInt > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < BigInt >) ; pub fn equals < T : From < Equals >> (value : Option < BigInt >) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: SkinId (_prisma :: read_filters :: BigIntNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntNullableFilter , SkinId , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : Option < BigInt >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: SkinId (v) } } pub struct Set (pub Option < BigInt >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SkinId (_prisma :: write_params :: BigIntNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Option < BigInt >) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: SkinId (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: SkinId (_prisma :: write_params :: BigIntNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: SkinId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: SkinId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: SkinId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod uploadable_textures { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "uploadableTextures" ; pub type Type = super :: super :: UploadableTextures ; pub type RecursiveSafeType = Type ; pub struct Equals (pub UploadableTextures) ; pub fn equals < T : From < Equals >> (value : UploadableTextures) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UploadableTextures (_prisma :: read_filters :: UploadableTexturesFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: UploadableTexturesFilter , UploadableTextures , { fn in_vec (_ : Vec < UploadableTextures >) -> InVec ; fn not_in_vec (_ : Vec < UploadableTextures >) -> NotInVec ; fn not (_ : UploadableTextures) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UploadableTextures (v) } } pub struct Set (pub UploadableTextures) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UploadableTextures (_prisma :: write_params :: UploadableTexturesParam :: Set (v)) } } pub fn set < T : From < Set >> (value : UploadableTextures) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: UploadableTexturesParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UploadableTextures (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UploadableTextures (_prisma :: write_params :: UploadableTexturesParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UploadableTextures (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UploadableTextures (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UploadableTextures (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod uuid { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "uuid" ; pub type Type = Bytes ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Bytes) ; pub fn equals < T : From < Equals >> (value : Bytes) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: UuidEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Uuid (_prisma :: read_filters :: BytesFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BytesFilter , Uuid , { fn in_vec (_ : Vec < Bytes >) -> InVec ; fn not_in_vec (_ : Vec < Bytes >) -> NotInVec ; fn not (_ : Bytes) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Uuid (v) } } pub struct Set (pub Bytes) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Uuid (_prisma :: write_params :: BytesParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Bytes) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BytesParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Uuid (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Uuid (_prisma :: write_params :: BytesParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Uuid (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Uuid (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Uuid (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod user { use super :: { _prisma :: * , * } ; pub const NAME : & str = "User" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , Uuid (super :: _prisma :: read_filters :: BytesFilter) , Nickname (super :: _prisma :: read_filters :: StringFilter) , Email (super :: _prisma :: read_filters :: StringFilter) , Password (super :: _prisma :: read_filters :: StringFilter) , Language (super :: _prisma :: read_filters :: LanguageFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , ProfileSome (Vec < super :: profile :: WhereParam >) , ProfileEvery (Vec < super :: profile :: WhereParam >) , ProfileNone (Vec < super :: profile :: WhereParam >) , SettingIsNull , SettingIs (Vec < super :: setting :: WhereParam >) , SettingIsNot (Vec < super :: setting :: WhereParam >) , TokenSome (Vec < super :: token :: WhereParam >) , TokenEvery (Vec < super :: token :: WhereParam >) , TokenNone (Vec < super :: token :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Uuid (value) => (uuid :: NAME , value . into ()) , Self :: Nickname (value) => (nickname :: NAME , value . into ()) , Self :: Email (value) => (email :: NAME , value . into ()) , Self :: Password (value) => (password :: NAME , value . into ()) , Self :: Language (value) => (language :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ProfileSome (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileEvery (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileNone (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: SettingIsNull => (setting :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Null)) , Self :: SettingIs (where_params) => (setting :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: SettingIsNot (where_params) => (setting :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenSome (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenEvery (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenNone (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) , UuidEquals (Bytes) , EmailEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) , UniqueWhereParam :: UuidEquals (value) => ("uuid" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Bytes (value))) , UniqueWhereParam :: EmailEquals (value) => ("email" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Uuid (super :: SortOrder) , Nickname (super :: SortOrder) , Email (super :: SortOrder) , Password (super :: SortOrder) , Language (super :: SortOrder) , CreatedAt (super :: SortOrder) , Profile (Vec < super :: profile :: OrderByRelationAggregateParam >) , Setting (Vec < super :: setting :: OrderByWithRelationParam >) , Token (Vec < super :: token :: OrderByRelationAggregateParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Uuid (param) => ("uuid" , param . into ()) , Self :: Nickname (param) => ("nickname" , param . into ()) , Self :: Email (param) => ("email" , param . into ()) , Self :: Password (param) => ("password" , param . into ()) , Self :: Language (param) => ("language" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Profile (param) => ("Profile" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Setting (param) => ("Setting" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Token (param) => ("Token" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Profile (super :: profile :: ManyArgs) , Setting (super :: setting :: UniqueArgs) , Token (super :: token :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Profile (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (profile :: NAME , None , arguments , nested_selections) } , Self :: Setting (args) => { let mut selections = < super :: setting :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (setting :: NAME , None , [] , selections) } , Self :: Token (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (token :: NAME , None , arguments , nested_selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Uuid (super :: _prisma :: write_params :: BytesParam) , Nickname (super :: _prisma :: write_params :: StringParam) , Email (super :: _prisma :: write_params :: StringParam) , Password (super :: _prisma :: write_params :: StringParam) , Language (super :: _prisma :: write_params :: LanguageParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , ConnectProfile (Vec < super :: profile :: UniqueWhereParam >) , DisconnectProfile (Vec < super :: profile :: UniqueWhereParam >) , SetProfile (Vec < super :: profile :: UniqueWhereParam >) , ConnectSetting (super :: setting :: UniqueWhereParam) , DisconnectSetting , ConnectToken (Vec < super :: token :: UniqueWhereParam >) , DisconnectToken (Vec < super :: token :: UniqueWhereParam >) , SetToken (Vec < super :: token :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Uuid (value) => (uuid :: NAME , value . into ()) , Self :: Nickname (value) => (nickname :: NAME , value . into ()) , Self :: Email (value) => (email :: NAME , value . into ()) , Self :: Password (value) => (password :: NAME , value . into ()) , Self :: Language (value) => (language :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ConnectProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetProfile (where_params) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: ConnectSetting (where_param) => (setting :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: DisconnectSetting => (setting :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) , Self :: ConnectToken (where_params) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectToken (where_params) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetToken (where_params) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , Uuid (super :: _prisma :: write_params :: BytesParam) , Nickname (super :: _prisma :: write_params :: StringParam) , Email (super :: _prisma :: write_params :: StringParam) , Password (super :: _prisma :: write_params :: StringParam) , Language (super :: _prisma :: write_params :: LanguageParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Uuid (value) => ("uuid" , value . into ()) , Self :: Nickname (value) => ("nickname" , value . into ()) , Self :: Email (value) => ("email" , value . into ()) , Self :: Password (value) => ("password" , value . into ()) , Self :: Language (value) => ("language" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_user , select , prisma :: user , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "uuid")] uuid : uuid :: Type , # [serde (rename = "nickname")] nickname : nickname :: Type , # [serde (rename = "email")] email : email :: Type , # [serde (rename = "password")] password : password :: Type , # [serde (rename = "language")] language : language :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "Profile")] profile : profile :: Type , # [serde (rename = "Setting")] setting : setting :: Type , # [serde (rename = "Token")] token : token :: Type } , [(id , Scalar) , (uuid , Scalar) , (nickname , Scalar) , (email , Scalar) , (password , Scalar) , (language , Scalar) , (created_at , Scalar) , (profile , Relation (prisma :: profile , Many)) , (setting , Relation (prisma :: setting , Optional)) , (token , Relation (prisma :: token , Many))]) ; pub enum SelectParam { Id (id :: Select) , Uuid (uuid :: Select) , Nickname (nickname :: Select) , Email (email :: Select) , Password (password :: Select) , Language (language :: Select) , CreatedAt (created_at :: Select) , Profile (profile :: Select) , Setting (setting :: Select) , Token (token :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Uuid (data) => data . into () , Self :: Nickname (data) => data . into () , Self :: Email (data) => data . into () , Self :: Password (data) => data . into () , Self :: Language (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Profile (data) => data . into () , Self :: Setting (data) => data . into () , Self :: Token (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_user , include , prisma :: user , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "uuid")] uuid : uuid :: Type , # [serde (rename = "nickname")] nickname : nickname :: Type , # [serde (rename = "email")] email : email :: Type , # [serde (rename = "password")] password : password :: Type , # [serde (rename = "language")] language : language :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "Profile")] profile : profile :: Type , # [serde (rename = "Setting")] setting : setting :: Type , # [serde (rename = "Token")] token : token :: Type } , [(profile , Relation (prisma :: profile , Many)) , (setting , Relation (prisma :: setting , Optional)) , (token , Relation (prisma :: token , Many))]) ; pub enum IncludeParam { Id (id :: Include) , Uuid (uuid :: Include) , Nickname (nickname :: Include) , Email (email :: Include) , Password (password :: Include) , Language (language :: Include) , CreatedAt (created_at :: Include) , Profile (profile :: Include) , Setting (setting :: Include) , Token (token :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Uuid (data) => data . into () , Self :: Nickname (data) => data . into () , Self :: Email (data) => data . into () , Self :: Password (data) => data . into () , Self :: Language (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Profile (data) => data . into () , Self :: Setting (data) => data . into () , Self :: Token (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub uuid : Bytes , pub nickname : String , pub email : String , pub password : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . user () . create (self . uuid , self . nickname , self . email , self . password , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([uuid :: set (self . uuid) , nickname :: set (self . nickname) , email :: set (self . email) , password :: set (self . password)]) ; self . _params } } pub fn create (uuid : Bytes , nickname : String , email : String , password : String , _params : Vec < SetParam >) -> Create { Create { uuid , nickname , email , password , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub uuid : Bytes , pub nickname : String , pub email : String , pub password : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . user () . create_unchecked (self . uuid , self . nickname , self . email , self . password , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([uuid :: set (self . uuid) , nickname :: set (self . nickname) , email :: set (self . email) , password :: set (self . password)]) ; self . _params } } pub fn create_unchecked (uuid : Bytes , nickname : String , email : String , password : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { uuid , nickname , email , password , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (uuid :: NAME) , :: prisma_client_rust :: sel (nickname :: NAME) , :: prisma_client_rust :: sel (email :: NAME) , :: prisma_client_rust :: sel (password :: NAME) , :: prisma_client_rust :: sel (language :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "uuid")] pub uuid : uuid :: Type , # [serde (rename = "nickname")] pub nickname : nickname :: Type , # [serde (rename = "email")] pub email : email :: Type , # [serde (rename = "password")] pub password : password :: Type , # [serde (rename = "language")] pub language : language :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "Profile")] pub profile : Option < profile :: RecursiveSafeType > , # [serde (rename = "Setting" , default , skip_serializing_if = "Option::is_none" , with = "prisma_client_rust::serde::double_option")] pub setting : Option < setting :: RecursiveSafeType > , # [serde (rename = "Token")] pub token : Option < token :: RecursiveSafeType > } impl Data { pub fn profile (& self) -> Result < & profile :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . profile . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (profile))) } pub fn setting (& self) -> Result < Option < & super :: setting :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . setting . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (setting))) . map (| v | v . as_ref () . map (| v | v . as_ref ())) } pub fn token (& self) -> Result < & token :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . token . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (token))) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_user , prisma :: user , struct Data { # [serde (rename = "id")] pub id : prisma :: user :: id :: Type , # [serde (rename = "uuid")] pub uuid : prisma :: user :: uuid :: Type , # [serde (rename = "nickname")] pub nickname : prisma :: user :: nickname :: Type , # [serde (rename = "email")] pub email : prisma :: user :: email :: Type , # [serde (rename = "password")] pub password : prisma :: user :: password :: Type , # [serde (rename = "language")] pub language : prisma :: user :: language :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: user :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_user_filter , prisma :: user , [(id , Scalar) , (uuid , Scalar) , (nickname , Scalar) , (email , Scalar) , (password , Scalar) , (language , Scalar) , (created_at , Scalar) , (profile , Relation (prisma :: profile , Many)) , (setting , Relation (prisma :: setting , Optional)) , (token , Relation (prisma :: token , Many))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , uuid : Bytes , nickname : String , email : String , password : String , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([uuid :: set (uuid) , nickname :: set (nickname) , email :: set (email) , password :: set (password)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , uuid : Bytes , nickname : String , email : String , password : String , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([uuid :: set (uuid) , nickname :: set (nickname) , email :: set (email) , password :: set (password)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod profile { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "Profile" ; pub type Type = Vec < profile :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileSome (value) } pub fn every (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileEvery (value) } pub fn none (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileNone (value) } pub struct Order (Vec < profile :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < profile :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Profile (v) } } pub struct Fetch (pub profile :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < profile :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : profile :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : profile :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Profile (v) } } pub fn fetch (params : Vec < profile :: WhereParam >) -> Fetch { Fetch (profile :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < profile :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectProfile (v) } } pub fn connect < T : From < Connect >> (params : Vec < profile :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < profile :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectProfile (params) } pub fn set (params : Vec < profile :: UniqueWhereParam >) -> SetParam { SetParam :: SetProfile (params) } pub enum Select { Select (profile :: ManyArgs , Vec < profile :: SelectParam >) , Include (profile :: ManyArgs , Vec < profile :: IncludeParam >) , Fetch (profile :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Profile (self) } } impl Select { pub fn select (args : profile :: ManyArgs , nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : profile :: ManyArgs , nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (profile :: ManyArgs , Vec < profile :: SelectParam >) , Include (profile :: ManyArgs , Vec < profile :: IncludeParam >) , Fetch (profile :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Profile (self) } } impl Include { pub fn select (args : profile :: ManyArgs , nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : profile :: ManyArgs , nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod setting { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "Setting" ; pub type Type = Option < setting :: Data > ; pub type RecursiveSafeType = Option < Box < setting :: Data >> ; pub fn is (value : Vec < setting :: WhereParam >) -> WhereParam { WhereParam :: SettingIs (value) } pub fn is_not (value : Vec < setting :: WhereParam >) -> WhereParam { WhereParam :: SettingIsNot (value) } pub struct Order (Vec < setting :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < setting :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Setting (v) } } pub struct Fetch (pub setting :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < setting :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Setting (v) } } pub fn fetch () -> Fetch { Fetch (setting :: UniqueArgs :: new ()) } pub struct Connect (setting :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectSetting (v) } } pub fn connect < T : From < Connect >> (value : setting :: UniqueWhereParam) -> T { Connect (value) . into () } pub fn disconnect () -> SetParam { SetParam :: DisconnectSetting } pub fn is_null () -> WhereParam { WhereParam :: SettingIsNull } pub enum Select { Select (Vec < setting :: SelectParam >) , Include (Vec < setting :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Setting (self) } } impl Select { pub fn select (nested_selections : Vec < setting :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < setting :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < setting :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("Setting" , None , [] , selections) } } pub enum Include { Select (Vec < setting :: SelectParam >) , Include (Vec < setting :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Setting (self) } } impl Include { pub fn select (nested_selections : Vec < setting :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < setting :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < setting :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < setting :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("Setting" , None , [] , selections) } } } pub mod token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "Token" ; pub type Type = Vec < token :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenSome (value) } pub fn every (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenEvery (value) } pub fn none (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenNone (value) } pub struct Order (Vec < token :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < token :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Token (v) } } pub struct Fetch (pub token :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < token :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : token :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : token :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Token (v) } } pub fn fetch (params : Vec < token :: WhereParam >) -> Fetch { Fetch (token :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < token :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectToken (v) } } pub fn connect < T : From < Connect >> (params : Vec < token :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < token :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectToken (params) } pub fn set (params : Vec < token :: UniqueWhereParam >) -> SetParam { SetParam :: SetToken (params) } pub enum Select { Select (token :: ManyArgs , Vec < token :: SelectParam >) , Include (token :: ManyArgs , Vec < token :: IncludeParam >) , Fetch (token :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Token (self) } } impl Select { pub fn select (args : token :: ManyArgs , nested_selections : Vec < token :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : token :: ManyArgs , nested_selections : Vec < token :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (token :: ManyArgs , Vec < token :: SelectParam >) , Include (token :: ManyArgs , Vec < token :: IncludeParam >) , Fetch (token :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Token (self) } } impl Include { pub fn select (args : token :: ManyArgs , nested_selections : Vec < token :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : token :: ManyArgs , nested_selections : Vec < token :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : DateTime) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : DateTime) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod email { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "email" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: EmailEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Email (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Email , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Email (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Email (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Email (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Email (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Email (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Email (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Email (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod language { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "language" ; pub type Type = super :: super :: Language ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Language) ; pub fn equals < T : From < Equals >> (value : Language) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Language (_prisma :: read_filters :: LanguageFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: LanguageFilter , Language , { fn in_vec (_ : Vec < Language >) -> InVec ; fn not_in_vec (_ : Vec < Language >) -> NotInVec ; fn not (_ : Language) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Language (v) } } pub struct Set (pub Language) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Language (_prisma :: write_params :: LanguageParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Language) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: LanguageParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Language (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Language (_prisma :: write_params :: LanguageParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Language (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Language (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Language (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod nickname { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "nickname" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Nickname (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Nickname , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Nickname (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Nickname (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Nickname (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Nickname (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Nickname (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Nickname (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Nickname (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod password { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "password" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Password (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Password , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Password (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Password (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Password (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Password (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Password (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Password (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Password (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod uuid { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "uuid" ; pub type Type = Bytes ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Bytes) ; pub fn equals < T : From < Equals >> (value : Bytes) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: UuidEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Uuid (_prisma :: read_filters :: BytesFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BytesFilter , Uuid , { fn in_vec (_ : Vec < Bytes >) -> InVec ; fn not_in_vec (_ : Vec < Bytes >) -> NotInVec ; fn not (_ : Bytes) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Uuid (v) } } pub struct Set (pub Bytes) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Uuid (_prisma :: write_params :: BytesParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Bytes) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BytesParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Uuid (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Uuid (_prisma :: write_params :: BytesParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Uuid (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Uuid (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Uuid (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod token { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Token" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , AccessToken (super :: _prisma :: read_filters :: StringFilter) , ClientToken (super :: _prisma :: read_filters :: StringFilter) , OwnerId (super :: _prisma :: read_filters :: BigIntFilter) , ProfileId (super :: _prisma :: read_filters :: BigIntNullableFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , Status (super :: _prisma :: read_filters :: TokenStatusFilter) , JoinRequestSome (Vec < super :: join_request :: WhereParam >) , JoinRequestEvery (Vec < super :: join_request :: WhereParam >) , JoinRequestNone (Vec < super :: join_request :: WhereParam >) , OwnerIs (Vec < super :: user :: WhereParam >) , OwnerIsNot (Vec < super :: user :: WhereParam >) , ProfileIsNull , ProfileIs (Vec < super :: profile :: WhereParam >) , ProfileIsNot (Vec < super :: profile :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: AccessToken (value) => (access_token :: NAME , value . into ()) , Self :: ClientToken (value) => (client_token :: NAME , value . into ()) , Self :: OwnerId (value) => (owner_id :: NAME , value . into ()) , Self :: ProfileId (value) => (profile_id :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: JoinRequestSome (where_params) => (join_request :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: JoinRequestEvery (where_params) => (join_request :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: JoinRequestNone (where_params) => (join_request :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: OwnerIs (where_params) => (owner :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: OwnerIsNot (where_params) => (owner :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileIsNull => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Null)) , Self :: ProfileIs (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProfileIsNot (where_params) => (profile :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) , AccessTokenEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) , UniqueWhereParam :: AccessTokenEquals (value) => ("accessToken" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , AccessToken (super :: SortOrder) , ClientToken (super :: SortOrder) , OwnerId (super :: SortOrder) , ProfileId (super :: SortOrder) , CreatedAt (super :: SortOrder) , Status (super :: SortOrder) , JoinRequest (Vec < super :: join_request :: OrderByRelationAggregateParam >) , Owner (Vec < super :: user :: OrderByWithRelationParam >) , Profile (Vec < super :: profile :: OrderByWithRelationParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: AccessToken (param) => ("accessToken" , param . into ()) , Self :: ClientToken (param) => ("clientToken" , param . into ()) , Self :: OwnerId (param) => ("ownerID" , param . into ()) , Self :: ProfileId (param) => ("profileID" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Status (param) => ("status" , param . into ()) , Self :: JoinRequest (param) => ("JoinRequest" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Owner (param) => ("owner" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: Profile (param) => ("profile" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum OrderByRelationAggregateParam { _Count (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByRelationAggregateParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: _Count (param) => ("_count" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { JoinRequest (super :: join_request :: ManyArgs) , Owner (super :: user :: UniqueArgs) , Profile (super :: profile :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: JoinRequest (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: join_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (join_request :: NAME , None , arguments , nested_selections) } , Self :: Owner (args) => { let mut selections = < super :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (owner :: NAME , None , [] , selections) } , Self :: Profile (args) => { let mut selections = < super :: profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (profile :: NAME , None , [] , selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , AccessToken (super :: _prisma :: write_params :: StringParam) , ClientToken (super :: _prisma :: write_params :: StringParam) , OwnerId (super :: _prisma :: write_params :: BigIntParam) , ProfileId (super :: _prisma :: write_params :: BigIntNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , Status (super :: _prisma :: write_params :: TokenStatusParam) , ConnectJoinRequest (Vec < super :: join_request :: UniqueWhereParam >) , DisconnectJoinRequest (Vec < super :: join_request :: UniqueWhereParam >) , SetJoinRequest (Vec < super :: join_request :: UniqueWhereParam >) , ConnectOwner (super :: user :: UniqueWhereParam) , ConnectProfile (super :: profile :: UniqueWhereParam) , DisconnectProfile } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: AccessToken (value) => (access_token :: NAME , value . into ()) , Self :: ClientToken (value) => (client_token :: NAME , value . into ()) , Self :: OwnerId (value) => (owner_id :: NAME , value . into ()) , Self :: ProfileId (value) => (profile_id :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: ConnectJoinRequest (where_params) => (join_request :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectJoinRequest (where_params) => (join_request :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetJoinRequest (where_params) => (join_request :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: ConnectOwner (where_param) => (owner :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: ConnectProfile (where_param) => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: DisconnectProfile => (profile :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , AccessToken (super :: _prisma :: write_params :: StringParam) , ClientToken (super :: _prisma :: write_params :: StringParam) , OwnerId (super :: _prisma :: write_params :: BigIntParam) , ProfileId (super :: _prisma :: write_params :: BigIntNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , Status (super :: _prisma :: write_params :: TokenStatusParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: AccessToken (value) => ("accessToken" , value . into ()) , Self :: ClientToken (value) => ("clientToken" , value . into ()) , Self :: OwnerId (value) => ("ownerID" , value . into ()) , Self :: ProfileId (value) => ("profileID" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: Status (value) => ("status" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_token , select , prisma :: token , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "accessToken")] access_token : access_token :: Type , # [serde (rename = "clientToken")] client_token : client_token :: Type , # [serde (rename = "ownerID")] owner_id : owner_id :: Type , # [serde (rename = "profileID")] profile_id : profile_id :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "JoinRequest")] join_request : join_request :: Type , # [serde (rename = "owner")] owner : owner :: Type , # [serde (rename = "profile")] profile : profile :: Type } , [(id , Scalar) , (access_token , Scalar) , (client_token , Scalar) , (owner_id , Scalar) , (profile_id , Scalar) , (created_at , Scalar) , (status , Scalar) , (join_request , Relation (prisma :: join_request , Many)) , (owner , Relation (prisma :: user , One)) , (profile , Relation (prisma :: profile , Optional))]) ; pub enum SelectParam { Id (id :: Select) , AccessToken (access_token :: Select) , ClientToken (client_token :: Select) , OwnerId (owner_id :: Select) , ProfileId (profile_id :: Select) , CreatedAt (created_at :: Select) , Status (status :: Select) , JoinRequest (join_request :: Select) , Owner (owner :: Select) , Profile (profile :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: AccessToken (data) => data . into () , Self :: ClientToken (data) => data . into () , Self :: OwnerId (data) => data . into () , Self :: ProfileId (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Status (data) => data . into () , Self :: JoinRequest (data) => data . into () , Self :: Owner (data) => data . into () , Self :: Profile (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_token , include , prisma :: token , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "accessToken")] access_token : access_token :: Type , # [serde (rename = "clientToken")] client_token : client_token :: Type , # [serde (rename = "ownerID")] owner_id : owner_id :: Type , # [serde (rename = "profileID")] profile_id : profile_id :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "JoinRequest")] join_request : join_request :: Type , # [serde (rename = "owner")] owner : owner :: Type , # [serde (rename = "profile")] profile : profile :: Type } , [(join_request , Relation (prisma :: join_request , Many)) , (owner , Relation (prisma :: user , One)) , (profile , Relation (prisma :: profile , Optional))]) ; pub enum IncludeParam { Id (id :: Include) , AccessToken (access_token :: Include) , ClientToken (client_token :: Include) , OwnerId (owner_id :: Include) , ProfileId (profile_id :: Include) , CreatedAt (created_at :: Include) , Status (status :: Include) , JoinRequest (join_request :: Include) , Owner (owner :: Include) , Profile (profile :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: AccessToken (data) => data . into () , Self :: ClientToken (data) => data . into () , Self :: OwnerId (data) => data . into () , Self :: ProfileId (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Status (data) => data . into () , Self :: JoinRequest (data) => data . into () , Self :: Owner (data) => data . into () , Self :: Profile (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub access_token : String , pub client_token : String , pub owner : super :: user :: UniqueWhereParam , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . token () . create (self . access_token , self . client_token , self . owner , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([access_token :: set (self . access_token) , client_token :: set (self . client_token) , owner :: connect (self . owner)]) ; self . _params } } pub fn create (access_token : String , client_token : String , owner : super :: user :: UniqueWhereParam , _params : Vec < SetParam >) -> Create { Create { access_token , client_token , owner , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub access_token : String , pub client_token : String , pub owner_id : BigInt , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . token () . create_unchecked (self . access_token , self . client_token , self . owner_id , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([access_token :: set (self . access_token) , client_token :: set (self . client_token) , owner_id :: set (self . owner_id)]) ; self . _params } } pub fn create_unchecked (access_token : String , client_token : String , owner_id : BigInt , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { access_token , client_token , owner_id , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (access_token :: NAME) , :: prisma_client_rust :: sel (client_token :: NAME) , :: prisma_client_rust :: sel (owner_id :: NAME) , :: prisma_client_rust :: sel (profile_id :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (status :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "accessToken")] pub access_token : access_token :: Type , # [serde (rename = "clientToken")] pub client_token : client_token :: Type , # [serde (rename = "ownerID")] pub owner_id : owner_id :: Type , # [serde (rename = "profileID")] pub profile_id : profile_id :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "status")] pub status : status :: Type , # [serde (rename = "JoinRequest")] pub join_request : Option < join_request :: RecursiveSafeType > , # [serde (rename = "owner")] pub owner : Option < owner :: RecursiveSafeType > , # [serde (rename = "profile" , default , skip_serializing_if = "Option::is_none" , with = "prisma_client_rust::serde::double_option")] pub profile : Option < profile :: RecursiveSafeType > } impl Data { pub fn join_request (& self) -> Result < & join_request :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . join_request . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (join_request))) } pub fn owner (& self) -> Result < & super :: user :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . owner . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (owner))) . map (| v | v . as_ref ()) } pub fn profile (& self) -> Result < Option < & super :: profile :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . profile . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (profile))) . map (| v | v . as_ref () . map (| v | v . as_ref ())) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_token , prisma :: token , struct Data { # [serde (rename = "id")] pub id : prisma :: token :: id :: Type , # [serde (rename = "accessToken")] pub access_token : prisma :: token :: access_token :: Type , # [serde (rename = "clientToken")] pub client_token : prisma :: token :: client_token :: Type , # [serde (rename = "ownerID")] pub owner_id : prisma :: token :: owner_id :: Type , # [serde (rename = "profileID")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub profile_id : prisma :: token :: profile_id :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: token :: created_at :: Type , # [serde (rename = "status")] pub status : prisma :: token :: status :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_token_filter , prisma :: token , [(id , Scalar) , (access_token , Scalar) , (client_token , Scalar) , (owner_id , Scalar) , (profile_id , Scalar) , (created_at , Scalar) , (status , Scalar) , (join_request , Relation (prisma :: join_request , Many)) , (owner , Relation (prisma :: user , One)) , (profile , Relation (prisma :: profile , Optional))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , access_token : String , client_token : String , owner : super :: user :: UniqueWhereParam , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([access_token :: set (access_token) , client_token :: set (client_token) , owner :: connect (owner)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , access_token : String , client_token : String , owner_id : BigInt , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([access_token :: set (access_token) , client_token :: set (client_token) , owner_id :: set (owner_id)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod join_request { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "JoinRequest" ; pub type Type = Vec < join_request :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < join_request :: WhereParam >) -> WhereParam { WhereParam :: JoinRequestSome (value) } pub fn every (value : Vec < join_request :: WhereParam >) -> WhereParam { WhereParam :: JoinRequestEvery (value) } pub fn none (value : Vec < join_request :: WhereParam >) -> WhereParam { WhereParam :: JoinRequestNone (value) } pub struct Order (Vec < join_request :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < join_request :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: JoinRequest (v) } } pub struct Fetch (pub join_request :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < join_request :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : join_request :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : join_request :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: JoinRequest (v) } } pub fn fetch (params : Vec < join_request :: WhereParam >) -> Fetch { Fetch (join_request :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < join_request :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectJoinRequest (v) } } pub fn connect < T : From < Connect >> (params : Vec < join_request :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < join_request :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectJoinRequest (params) } pub fn set (params : Vec < join_request :: UniqueWhereParam >) -> SetParam { SetParam :: SetJoinRequest (params) } pub enum Select { Select (join_request :: ManyArgs , Vec < join_request :: SelectParam >) , Include (join_request :: ManyArgs , Vec < join_request :: IncludeParam >) , Fetch (join_request :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: JoinRequest (self) } } impl Select { pub fn select (args : join_request :: ManyArgs , nested_selections : Vec < join_request :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : join_request :: ManyArgs , nested_selections : Vec < join_request :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < join_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (join_request :: ManyArgs , Vec < join_request :: SelectParam >) , Include (join_request :: ManyArgs , Vec < join_request :: IncludeParam >) , Fetch (join_request :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: JoinRequest (self) } } impl Include { pub fn select (args : join_request :: ManyArgs , nested_selections : Vec < join_request :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : join_request :: ManyArgs , nested_selections : Vec < join_request :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < join_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < join_request :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod _count { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "_count" ; pub struct Order (super :: SortOrder) ; pub fn order < T : From < Order >> (v : super :: SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByRelationAggregateParam { fn from (Order (v) : Order) -> Self { Self :: _Count (v) } } } pub mod access_token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "accessToken" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: AccessTokenEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: AccessToken (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , AccessToken , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: AccessToken (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: AccessToken (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AccessToken (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: AccessToken (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AccessToken (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: AccessToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: AccessToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod client_token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "clientToken" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ClientToken (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ClientToken , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ClientToken (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ClientToken (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ClientToken (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ClientToken (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ClientToken (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ClientToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ClientToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : DateTime) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : DateTime) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod owner { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "owner" ; pub type Type = user :: Data ; pub type RecursiveSafeType = Box < user :: Data > ; pub fn is (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: OwnerIs (value) } pub fn is_not (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: OwnerIsNot (value) } pub struct Order (Vec < user :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < user :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Owner (v) } } pub struct Fetch (pub user :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < user :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Owner (v) } } pub fn fetch () -> Fetch { Fetch (user :: UniqueArgs :: new ()) } pub struct Connect (user :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectOwner (v) } } pub fn connect < T : From < Connect >> (value : user :: UniqueWhereParam) -> T { Connect (value) . into () } pub enum Select { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Owner (self) } } impl Select { pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("owner" , None , [] , selections) } } pub enum Include { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Owner (self) } } impl Include { pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("owner" , None , [] , selections) } } } pub mod owner_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "ownerID" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: OwnerId (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , OwnerId , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: OwnerId (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: OwnerId (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: OwnerId (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: OwnerId (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: OwnerId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: OwnerId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: OwnerId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod profile { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "profile" ; pub type Type = Option < profile :: Data > ; pub type RecursiveSafeType = Option < Box < profile :: Data >> ; pub fn is (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileIs (value) } pub fn is_not (value : Vec < profile :: WhereParam >) -> WhereParam { WhereParam :: ProfileIsNot (value) } pub struct Order (Vec < profile :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < profile :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Profile (v) } } pub struct Fetch (pub profile :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < profile :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Profile (v) } } pub fn fetch () -> Fetch { Fetch (profile :: UniqueArgs :: new ()) } pub struct Connect (profile :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectProfile (v) } } pub fn connect < T : From < Connect >> (value : profile :: UniqueWhereParam) -> T { Connect (value) . into () } pub fn disconnect () -> SetParam { SetParam :: DisconnectProfile } pub fn is_null () -> WhereParam { WhereParam :: ProfileIsNull } pub enum Select { Select (Vec < profile :: SelectParam >) , Include (Vec < profile :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Profile (self) } } impl Select { pub fn select (nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("profile" , None , [] , selections) } } pub enum Include { Select (Vec < profile :: SelectParam >) , Include (Vec < profile :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Profile (self) } } impl Include { pub fn select (nested_selections : Vec < profile :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < profile :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < profile :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("profile" , None , [] , selections) } } } pub mod profile_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "profileID" ; pub type Type = Option < BigInt > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < BigInt >) ; pub fn equals < T : From < Equals >> (value : Option < BigInt >) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProfileId (_prisma :: read_filters :: BigIntNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntNullableFilter , ProfileId , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : Option < BigInt >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProfileId (v) } } pub struct Set (pub Option < BigInt >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProfileId (_prisma :: write_params :: BigIntNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Option < BigInt >) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProfileId (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntNullableParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProfileId (_prisma :: write_params :: BigIntNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProfileId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProfileId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProfileId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod status { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "status" ; pub type Type = super :: super :: TokenStatus ; pub type RecursiveSafeType = Type ; pub struct Equals (pub TokenStatus) ; pub fn equals < T : From < Equals >> (value : TokenStatus) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Status (_prisma :: read_filters :: TokenStatusFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: TokenStatusFilter , Status , { fn in_vec (_ : Vec < TokenStatus >) -> InVec ; fn not_in_vec (_ : Vec < TokenStatus >) -> NotInVec ; fn not (_ : TokenStatus) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Status (v) } } pub struct Set (pub TokenStatus) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: TokenStatusParam :: Set (v)) } } pub fn set < T : From < Set >> (value : TokenStatus) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: TokenStatusParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: TokenStatusParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod join_request { use super :: { _prisma :: * , * } ; pub const NAME : & str = "JoinRequest" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , ServerId (super :: _prisma :: read_filters :: StringFilter) , AccessToken (super :: _prisma :: read_filters :: StringFilter) , Ip (super :: _prisma :: read_filters :: StringFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , TokenIs (Vec < super :: token :: WhereParam >) , TokenIsNot (Vec < super :: token :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ServerId (value) => (server_id :: NAME , value . into ()) , Self :: AccessToken (value) => (access_token :: NAME , value . into ()) , Self :: Ip (value) => (ip :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: TokenIs (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TokenIsNot (where_params) => (token :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) , ServerIdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) , UniqueWhereParam :: ServerIdEquals (value) => ("serverID" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , ServerId (super :: SortOrder) , AccessToken (super :: SortOrder) , Ip (super :: SortOrder) , CreatedAt (super :: SortOrder) , Token (Vec < super :: token :: OrderByWithRelationParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: ServerId (param) => ("serverID" , param . into ()) , Self :: AccessToken (param) => ("accessToken" , param . into ()) , Self :: Ip (param) => ("ip" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Token (param) => ("token" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum OrderByRelationAggregateParam { _Count (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByRelationAggregateParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: _Count (param) => ("_count" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Token (super :: token :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Token (args) => { let mut selections = < super :: token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (token :: NAME , None , [] , selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , ServerId (super :: _prisma :: write_params :: StringParam) , AccessToken (super :: _prisma :: write_params :: StringParam) , Ip (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , ConnectToken (super :: token :: UniqueWhereParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ServerId (value) => (server_id :: NAME , value . into ()) , Self :: AccessToken (value) => (access_token :: NAME , value . into ()) , Self :: Ip (value) => (ip :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: ConnectToken (where_param) => (token :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , ServerId (super :: _prisma :: write_params :: StringParam) , AccessToken (super :: _prisma :: write_params :: StringParam) , Ip (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: ServerId (value) => ("serverID" , value . into ()) , Self :: AccessToken (value) => ("accessToken" , value . into ()) , Self :: Ip (value) => ("ip" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_join_request , select , prisma :: join_request , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "serverID")] server_id : server_id :: Type , # [serde (rename = "accessToken")] access_token : access_token :: Type , # [serde (rename = "ip")] ip : ip :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "token")] token : token :: Type } , [(id , Scalar) , (server_id , Scalar) , (access_token , Scalar) , (ip , Scalar) , (created_at , Scalar) , (token , Relation (prisma :: token , One))]) ; pub enum SelectParam { Id (id :: Select) , ServerId (server_id :: Select) , AccessToken (access_token :: Select) , Ip (ip :: Select) , CreatedAt (created_at :: Select) , Token (token :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ServerId (data) => data . into () , Self :: AccessToken (data) => data . into () , Self :: Ip (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Token (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_join_request , include , prisma :: join_request , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "serverID")] server_id : server_id :: Type , # [serde (rename = "accessToken")] access_token : access_token :: Type , # [serde (rename = "ip")] ip : ip :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "token")] token : token :: Type } , [(token , Relation (prisma :: token , One))]) ; pub enum IncludeParam { Id (id :: Include) , ServerId (server_id :: Include) , AccessToken (access_token :: Include) , Ip (ip :: Include) , CreatedAt (created_at :: Include) , Token (token :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ServerId (data) => data . into () , Self :: AccessToken (data) => data . into () , Self :: Ip (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: Token (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub server_id : String , pub ip : String , pub token : super :: token :: UniqueWhereParam , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . join_request () . create (self . server_id , self . ip , self . token , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([server_id :: set (self . server_id) , ip :: set (self . ip) , token :: connect (self . token)]) ; self . _params } } pub fn create (server_id : String , ip : String , token : super :: token :: UniqueWhereParam , _params : Vec < SetParam >) -> Create { Create { server_id , ip , token , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub server_id : String , pub access_token : String , pub ip : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . join_request () . create_unchecked (self . server_id , self . access_token , self . ip , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([server_id :: set (self . server_id) , access_token :: set (self . access_token) , ip :: set (self . ip)]) ; self . _params } } pub fn create_unchecked (server_id : String , access_token : String , ip : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { server_id , access_token , ip , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (server_id :: NAME) , :: prisma_client_rust :: sel (access_token :: NAME) , :: prisma_client_rust :: sel (ip :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "serverID")] pub server_id : server_id :: Type , # [serde (rename = "accessToken")] pub access_token : access_token :: Type , # [serde (rename = "ip")] pub ip : ip :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "token")] pub token : Option < token :: RecursiveSafeType > } impl Data { pub fn token (& self) -> Result < & super :: token :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . token . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (token))) . map (| v | v . as_ref ()) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_join_request , prisma :: join_request , struct Data { # [serde (rename = "id")] pub id : prisma :: join_request :: id :: Type , # [serde (rename = "serverID")] pub server_id : prisma :: join_request :: server_id :: Type , # [serde (rename = "accessToken")] pub access_token : prisma :: join_request :: access_token :: Type , # [serde (rename = "ip")] pub ip : prisma :: join_request :: ip :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: join_request :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_join_request_filter , prisma :: join_request , [(id , Scalar) , (server_id , Scalar) , (access_token , Scalar) , (ip , Scalar) , (created_at , Scalar) , (token , Relation (prisma :: token , One))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , server_id : String , ip : String , token : super :: token :: UniqueWhereParam , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([server_id :: set (server_id) , ip :: set (ip) , token :: connect (token)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , server_id : String , access_token : String , ip : String , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([server_id :: set (server_id) , access_token :: set (access_token) , ip :: set (ip)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod _count { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "_count" ; pub struct Order (super :: SortOrder) ; pub fn order < T : From < Order >> (v : super :: SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByRelationAggregateParam { fn from (Order (v) : Order) -> Self { Self :: _Count (v) } } } pub mod access_token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "accessToken" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: AccessToken (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , AccessToken , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: AccessToken (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: AccessToken (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AccessToken (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: AccessToken (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AccessToken (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: AccessToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: AccessToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : DateTime) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : DateTime) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod ip { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "ip" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Ip (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Ip , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Ip (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Ip (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Ip (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Ip (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Ip (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Ip (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Ip (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod server_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "serverID" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: ServerIdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ServerId (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ServerId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn mode (_ : QueryMode) -> Mode ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ServerId (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ServerId (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ServerId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ServerId (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ServerId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ServerId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ServerId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "token" ; pub type Type = token :: Data ; pub type RecursiveSafeType = Box < token :: Data > ; pub fn is (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenIs (value) } pub fn is_not (value : Vec < token :: WhereParam >) -> WhereParam { WhereParam :: TokenIsNot (value) } pub struct Order (Vec < token :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < token :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Token (v) } } pub struct Fetch (pub token :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < token :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Token (v) } } pub fn fetch () -> Fetch { Fetch (token :: UniqueArgs :: new ()) } pub struct Connect (token :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectToken (v) } } pub fn connect < T : From < Connect >> (value : token :: UniqueWhereParam) -> T { Connect (value) . into () } pub enum Select { Select (Vec < token :: SelectParam >) , Include (Vec < token :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Token (self) } } impl Select { pub fn select (nested_selections : Vec < token :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < token :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("token" , None , [] , selections) } } pub enum Include { Select (Vec < token :: SelectParam >) , Include (Vec < token :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Token (self) } } impl Include { pub fn select (nested_selections : Vec < token :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < token :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("token" , None , [] , selections) } } } } pub mod setting { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Setting" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: BigIntFilter) , UserId (super :: _prisma :: read_filters :: BigIntFilter) , MaxToken (super :: _prisma :: read_filters :: BigIntFilter) , TokenNeedRefreshDuration (super :: _prisma :: read_filters :: BigIntFilter) , TokenInvalidDuration (super :: _prisma :: read_filters :: BigIntFilter) , UserIs (Vec < super :: user :: WhereParam >) , UserIsNot (Vec < super :: user :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: UserId (value) => (user_id :: NAME , value . into ()) , Self :: MaxToken (value) => (max_token :: NAME , value . into ()) , Self :: TokenNeedRefreshDuration (value) => (token_need_refresh_duration :: NAME , value . into ()) , Self :: TokenInvalidDuration (value) => (token_invalid_duration :: NAME , value . into ()) , Self :: UserIs (where_params) => (user :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: UserIsNot (where_params) => (user :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (BigInt) , UserIdEquals (BigInt) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) , UniqueWhereParam :: UserIdEquals (value) => ("userId" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: BigInt (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , UserId (super :: SortOrder) , MaxToken (super :: SortOrder) , TokenNeedRefreshDuration (super :: SortOrder) , TokenInvalidDuration (super :: SortOrder) , User (Vec < super :: user :: OrderByWithRelationParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: UserId (param) => ("userId" , param . into ()) , Self :: MaxToken (param) => ("maxToken" , param . into ()) , Self :: TokenNeedRefreshDuration (param) => ("tokenNeedRefreshDuration" , param . into ()) , Self :: TokenInvalidDuration (param) => ("tokenInvalidDuration" , param . into ()) , Self :: User (param) => ("user" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { User (super :: user :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: User (args) => { let mut selections = < super :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (user :: NAME , None , [] , selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: BigIntParam) , UserId (super :: _prisma :: write_params :: BigIntParam) , MaxToken (super :: _prisma :: write_params :: BigIntParam) , TokenNeedRefreshDuration (super :: _prisma :: write_params :: BigIntParam) , TokenInvalidDuration (super :: _prisma :: write_params :: BigIntParam) , ConnectUser (super :: user :: UniqueWhereParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: UserId (value) => (user_id :: NAME , value . into ()) , Self :: MaxToken (value) => (max_token :: NAME , value . into ()) , Self :: TokenNeedRefreshDuration (value) => (token_need_refresh_duration :: NAME , value . into ()) , Self :: TokenInvalidDuration (value) => (token_invalid_duration :: NAME , value . into ()) , Self :: ConnectUser (where_param) => (user :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: BigIntParam) , UserId (super :: _prisma :: write_params :: BigIntParam) , MaxToken (super :: _prisma :: write_params :: BigIntParam) , TokenNeedRefreshDuration (super :: _prisma :: write_params :: BigIntParam) , TokenInvalidDuration (super :: _prisma :: write_params :: BigIntParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: UserId (value) => ("userId" , value . into ()) , Self :: MaxToken (value) => ("maxToken" , value . into ()) , Self :: TokenNeedRefreshDuration (value) => ("tokenNeedRefreshDuration" , value . into ()) , Self :: TokenInvalidDuration (value) => ("tokenInvalidDuration" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_setting , select , prisma :: setting , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "userId")] user_id : user_id :: Type , # [serde (rename = "maxToken")] max_token : max_token :: Type , # [serde (rename = "tokenNeedRefreshDuration")] token_need_refresh_duration : token_need_refresh_duration :: Type , # [serde (rename = "tokenInvalidDuration")] token_invalid_duration : token_invalid_duration :: Type , # [serde (rename = "user")] user : user :: Type } , [(id , Scalar) , (user_id , Scalar) , (max_token , Scalar) , (token_need_refresh_duration , Scalar) , (token_invalid_duration , Scalar) , (user , Relation (prisma :: user , One))]) ; pub enum SelectParam { Id (id :: Select) , UserId (user_id :: Select) , MaxToken (max_token :: Select) , TokenNeedRefreshDuration (token_need_refresh_duration :: Select) , TokenInvalidDuration (token_invalid_duration :: Select) , User (user :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: UserId (data) => data . into () , Self :: MaxToken (data) => data . into () , Self :: TokenNeedRefreshDuration (data) => data . into () , Self :: TokenInvalidDuration (data) => data . into () , Self :: User (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_setting , include , prisma :: setting , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "userId")] user_id : user_id :: Type , # [serde (rename = "maxToken")] max_token : max_token :: Type , # [serde (rename = "tokenNeedRefreshDuration")] token_need_refresh_duration : token_need_refresh_duration :: Type , # [serde (rename = "tokenInvalidDuration")] token_invalid_duration : token_invalid_duration :: Type , # [serde (rename = "user")] user : user :: Type } , [(user , Relation (prisma :: user , One))]) ; pub enum IncludeParam { Id (id :: Include) , UserId (user_id :: Include) , MaxToken (max_token :: Include) , TokenNeedRefreshDuration (token_need_refresh_duration :: Include) , TokenInvalidDuration (token_invalid_duration :: Include) , User (user :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: UserId (data) => data . into () , Self :: MaxToken (data) => data . into () , Self :: TokenNeedRefreshDuration (data) => data . into () , Self :: TokenInvalidDuration (data) => data . into () , Self :: User (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub user : super :: user :: UniqueWhereParam , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . setting () . create (self . user , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([user :: connect (self . user)]) ; self . _params } } pub fn create (user : super :: user :: UniqueWhereParam , _params : Vec < SetParam >) -> Create { Create { user , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub user_id : BigInt , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . setting () . create_unchecked (self . user_id , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([user_id :: set (self . user_id)]) ; self . _params } } pub fn create_unchecked (user_id : BigInt , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { user_id , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (user_id :: NAME) , :: prisma_client_rust :: sel (max_token :: NAME) , :: prisma_client_rust :: sel (token_need_refresh_duration :: NAME) , :: prisma_client_rust :: sel (token_invalid_duration :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "userId")] pub user_id : user_id :: Type , # [serde (rename = "maxToken")] pub max_token : max_token :: Type , # [serde (rename = "tokenNeedRefreshDuration")] pub token_need_refresh_duration : token_need_refresh_duration :: Type , # [serde (rename = "tokenInvalidDuration")] pub token_invalid_duration : token_invalid_duration :: Type , # [serde (rename = "user")] pub user : Option < user :: RecursiveSafeType > } impl Data { pub fn user (& self) -> Result < & super :: user :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . user . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (user))) . map (| v | v . as_ref ()) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_setting , prisma :: setting , struct Data { # [serde (rename = "id")] pub id : prisma :: setting :: id :: Type , # [serde (rename = "userId")] pub user_id : prisma :: setting :: user_id :: Type , # [serde (rename = "maxToken")] pub max_token : prisma :: setting :: max_token :: Type , # [serde (rename = "tokenNeedRefreshDuration")] pub token_need_refresh_duration : prisma :: setting :: token_need_refresh_duration :: Type , # [serde (rename = "tokenInvalidDuration")] pub token_invalid_duration : prisma :: setting :: token_invalid_duration :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_setting_filter , prisma :: setting , [(id , Scalar) , (user_id , Scalar) , (max_token , Scalar) , (token_need_refresh_duration , Scalar) , (token_invalid_duration , Scalar) , (user , Relation (prisma :: user , One))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , user : super :: user :: UniqueWhereParam , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([user :: connect (user)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , user_id : BigInt , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([user_id :: set (user_id)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , Id , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod max_token { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "maxToken" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: MaxToken (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , MaxToken , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: MaxToken (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: MaxToken (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: MaxToken (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: MaxToken (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: MaxToken (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: MaxToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: MaxToken (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod token_invalid_duration { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "tokenInvalidDuration" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: TokenInvalidDuration (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , TokenInvalidDuration , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: TokenInvalidDuration (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: TokenInvalidDuration (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TokenInvalidDuration (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: TokenInvalidDuration (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TokenInvalidDuration (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: TokenInvalidDuration (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: TokenInvalidDuration (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod token_need_refresh_duration { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "tokenNeedRefreshDuration" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: TokenNeedRefreshDuration (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , TokenNeedRefreshDuration , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: TokenNeedRefreshDuration (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: TokenNeedRefreshDuration (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TokenNeedRefreshDuration (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: TokenNeedRefreshDuration (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TokenNeedRefreshDuration (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: TokenNeedRefreshDuration (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: TokenNeedRefreshDuration (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod user { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "user" ; pub type Type = user :: Data ; pub type RecursiveSafeType = Box < user :: Data > ; pub fn is (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: UserIs (value) } pub fn is_not (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: UserIsNot (value) } pub struct Order (Vec < user :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < user :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: User (v) } } pub struct Fetch (pub user :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < user :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: User (v) } } pub fn fetch () -> Fetch { Fetch (user :: UniqueArgs :: new ()) } pub struct Connect (user :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectUser (v) } } pub fn connect < T : From < Connect >> (value : user :: UniqueWhereParam) -> T { Connect (value) . into () } pub enum Select { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: User (self) } } impl Select { pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("user" , None , [] , selections) } } pub enum Include { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: User (self) } } impl Include { pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("user" , None , [] , selections) } } } pub mod user_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "userId" ; pub type Type = BigInt ; pub type RecursiveSafeType = Type ; pub struct Equals (pub BigInt) ; pub fn equals < T : From < Equals >> (value : BigInt) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: UserIdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UserId (_prisma :: read_filters :: BigIntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BigIntFilter , UserId , { fn in_vec (_ : Vec < BigInt >) -> InVec ; fn not_in_vec (_ : Vec < BigInt >) -> NotInVec ; fn lt (_ : BigInt) -> Lt ; fn lte (_ : BigInt) -> Lte ; fn gt (_ : BigInt) -> Gt ; fn gte (_ : BigInt) -> Gte ; fn not (_ : BigInt) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UserId (v) } } pub struct Set (pub BigInt) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UserId (_prisma :: write_params :: BigIntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : BigInt) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BigIntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UserId (v) } } pub fn increment < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : BigInt) -> T { UpdateOperation (_prisma :: write_params :: BigIntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UserId (_prisma :: write_params :: BigIntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UserId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UserId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UserId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } }